1. 将工具的调用作为用户的消息填充到对话的构建中，这样可以优化对话构建，而不是每一次都将初始化提示词都发送给模型，减少token消耗，例如
user： 修改xxx文件，修改之前先阅读xxx文件。
ai：我将调用阅读xxx的工具（输出工具调用）
user： 工具调用成功，输出xxx
类似这样的对话构建。但是需要每次在user内容开始位置强调输出内容格式规范

ok

2. 优化内容输出提示词构建。使得除了思维链以外，内容数据输出也能够做到流式输出
这需要优化提示词，需要模型怎样输出才能做到工具预览与执行并行存在。

目前方案

只输出 NDJSON（每行一个 JSON 对象，行尾 \n）。不要输出任何行外文本或空行。
任意二进制或多行文本一律使用 base64。

事件定义：
- {"type":"preview","id":"w1","path_b64":"src/a.ts","lang":"diff","bs64":"b1"}      // 预览引用 bs64
- {"type":"tool","id":"w1","tool":"file_write","data":{
    "path_b64":"src/a.ts",
    "originalCode_b64":"<可选，若必须>",
    "new_bs64":"b1",                      // 直接引用 b1，不重复发内容
    "summary":"..."
  }}
- {"type":"done"}
- {"type":"bs64_start","id":"b1","mime":"text/plain","desc":"<可选说明>"}
- {"type":"bs64_chunk","id":"b1","seq":0,"data_b64":"<<=4KB base64>"}
- {"type":"bs64_end","id":"b1","hash":"sha256:<对完整拼接字符串计算>"}


约束：
- bs64 的内容只传一次，预览和工具都通过 "bs64":"<id>" 引用。
- 大字段必须切片为 bs64_chunk（seq 从0递增）；结束时提供 hash 以校验完整性。
- 多个文件可并行：先发preview/tool 行, 再发各自的 bs64 。

3. 文件读取工具的优化。不需要读取全部文件内容，可以要求ai进行200行200行的分批读取，一旦ai确认读取完毕，停止读取调用。
4. 提供新功能：在ai读取文件的时候，可以使用搜索功能，即本地代码库进行全局搜索，找出特征函数出现的位置，包括文件地址，出现行号

5. 3个主要工具：
    文件编辑
    文件新建
    shell执行。
6. 3个主要工具问题：
    文件删除如何复原
    文件编辑如何撤销部分编辑内容
    文件新建如果撤销


